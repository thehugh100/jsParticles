<html>
<head>
    <script src="two.js"></script>
    <style>
        .toolbar {
            width: 100%;
            float: left;
        }
        #scene {
            width: 100%;
        }
    </style>
</head>

<body>
    <!-- <input id="sf" type="range" min="0" max="2"/> -->
    <div class="toolbar">
        <!-- <input type="number" id="sf" style="z-index: 10;"/> -->
    </div>
    <div id="scene"></div>
    <script>
        
        var two = new Two({
            type: Two.Types.canvas,
            fullscreen: true,
            autostart: true
        }).appendTo(document.getElementById("scene"));
        
        var ls = [];
        var springs = [];
        var amt = 40;
        var gravity = new Two.Vector(0, 0.08);
        var mousePos = new Two.Vector(0, 0);
        var mouseState = 0;
        var shiftClick = 0;
        var dragging = 0;
        var draggingIdx = 0;
        var pause = 0;
        var globalSpringForceMultiplier = 1.;
        var globalDampingForceMult = 1.;

        function zv() {
            return new Two.Vector(0,0);
        }

        function rand() {
            return Math.random() - .5;
        }

        function createCircle(pos, vel) {
            var circ = new Two.Circle(0, 0, 10, 10);
            var line = new Two.Line(0,0,10,0);
            ls.push({
                shape: circ,
                line: line,
                pos: pos,
                vel: vel,
                mass: 1,
                radius: 10,
                id: ls.length,
                selected: 0,
                static: 0,
                // Avoiding use of .clone() (and allocating new vectors by statically allocating them here)
                _tangent: zv(), 
                _normal: zv(),
                _invNormal: zv(),
                _col1: zv(),
                _col2: zv(),
                _tmp: zv(),
                _tmp2: zv(),
                _tmp3: zv()
            });
            two.add(circ);
            two.add(line);
            return ls[ls.length - 1];
        }

        function createSpring(s1, s2, force = 0.2048, damping = 0.1) {
            var line = new Two.Line(s1.pos.x, s1.pos.y, s2.pos.x, s2.pos.y);
            springs.push({
                line: line,
                s1: s1,
                s2: s2,
                dist: s1.pos.clone().distanceTo(s2.pos),
                force: force,
                damping: damping,
            });
            two.add(line);
            return springs[springs.length - 1];
        }

        function createBall() {
            for(var i = 0; i < 16; i++) {
                var d = 360/16;
                var x = Math.cos(i * d * 3.14 / 180) * 92;
                var y = Math.sin(i * d * 3.14 / 180) * 92;

                var p = createCircle(
                    new Two.Vector(two.width * .5 + x, two.height * .5 + y),
                    zv()
                );

                if(i>=1) {
                    //createSpring(p, ls[p.id-1]);
                }
            }
            //createSpring(ls[ls.length-1], ls[ls.length-16]);

            // for(var i = 0; i < 8; i++) {
            //     createSpring(ls[ls.length-16 + i], ls[ls.length-16 + i + 8]);
            // }

            for(var i = 0; i < 16; i++) {
                for(var j = 0; j < 16; j++) {
                    if(i!=j) {
                        createSpring(ls[ls.length-16 + i], ls[ls.length-16 + j]);
                    }
                }
            }
        }
    
        for(var i = 0; i < 8; i++) {
            var p1 = createCircle(new Two.Vector(two.width * .5 - 32, 100 + i * 64), zv());
            var p2 = createCircle(new Two.Vector(two.width * .5 + 32, 100 + i * 64), zv());
            createSpring(p1, p2);
            if(i >= 1) {
                createSpring(p1, ls[p1.id - 2]);
                createSpring(p2, ls[p2.id - 2]);
                createSpring(p1, ls[p1.id - 1]);
                createSpring(p2, ls[p2.id - 3]);

            }
        }

        function processSprings() {
            for (var i = 0; i < springs.length; i++) {
                    var spring = springs[i];
                    var normS1 = spring.s1.pos.clone().subtract(spring.s2.pos).normalize();
                    var normS2 = spring.s2.pos.clone().subtract(spring.s1.pos).normalize();

                    var distC = spring.s1.pos.clone().distanceTo(spring.s2.pos);

                    var relativeVelS1 = spring.s1.vel.clone().sub(spring.s2.vel);
                    var relativeVelS2 = spring.s2.vel.clone().sub(spring.s1.vel);

                    var dampingS1 = normS1.clone().multiply(spring.damping * globalDampingForceMult * relativeVelS1.clone().dot(normS1));
                    var dampingS2 = normS2.clone().multiply(spring.damping * globalDampingForceMult * relativeVelS2.clone().dot(normS2));

                    var forceS1 = normS1.clone().multiply(spring.dist - distC).multiply(spring.force * globalSpringForceMultiplier);
                    var forceS2 = normS2.clone().multiply(spring.dist - distC).multiply(spring.force * globalSpringForceMultiplier);

                    forceS1.sub(dampingS1);
                    forceS2.sub(dampingS2);

                    spring.s1.vel.addSelf(forceS1.clone().multiply(1 / spring.s1.mass));
                    spring.s2.vel.addSelf(forceS2.clone().multiply(1 / spring.s2.mass));
                }
        }

        function processCircles() {
            for (var i = 0; i < ls.length; i++) {
                var obj = ls[i];
                if(!obj.static) {
                    obj.vel.addSelf(gravity);
                    obj.vel.x *= .9999;
                    obj.vel.y *= .9999;
                }

                for (var j = 0; j < ls.length; j++) {
                    if (i != j) {
                        var obj2 = ls[j];
                        var manhattenDist = Math.abs(obj.pos.x - obj2.pos.x) + Math.abs(obj.pos.y - obj2.pos.y);
                        if(manhattenDist < 30) {
                            var delta = obj.pos.distanceTo(obj2.pos);
                            if (delta < obj.radius + obj2.radius) {
                                
                                var normal = obj._normal.copy(obj.pos).sub(obj2.pos).normalize();
                                var overlap = (obj.radius + obj2.radius) - delta;
                                if(!obj.static) {
                                    obj.pos.addSelf(obj._col1.copy(normal).multiply(overlap * .5001));
                                }
                                if(!obj2.static) {
                                    obj2.pos.addSelf(obj._col2.copy(normal).negate().multiply(overlap * .5001));
                                }
                                
                                var tangentVector = obj._tangent;
                                tangentVector.clear();
                                tangentVector.y = -(obj2.pos.x - obj.pos.x);
                                tangentVector.x = obj2.pos.y - obj.pos.y;
                                tangentVector.normalize();
                                var relVel = obj._tmp.copy(obj2.vel).sub(obj.vel);
                                var length = obj._tmp2.copy(relVel).dot(tangentVector);
                                var velocityComponentOnTangent = obj._tmp3.copy(tangentVector).multiply(length);
                                var velocityComponentPerpendicularToTangent = relVel.sub(velocityComponentOnTangent).multiply(0.8);
                                obj.vel.add(velocityComponentPerpendicularToTangent);
                                obj2.vel.sub(velocityComponentPerpendicularToTangent);
                            }
                        }
                    }
                }
                if(obj.static) {
                    obj.vel = zv();
                }
            }
        }

        function linkSelectedCircles() {
            for(var i = 0; i < ls.length; i++) {
                for(var j = 0; j < ls.length; j++) {
                    if(i != j && ls[i].selected && ls[j].selected) {
                        var exists = 0;
                        for(var k = 0; k < springs.length; k++) {
                            var spring = springs[k];
                            if(
                                (spring.s1 == ls[i] && spring.s2 == ls[j]) ||
                                (spring.s2 == ls[i] && spring.s1 == ls[j])
                            ) {
                                exists = 1;
                                break;
                            }
                        }
                        if(!exists) {
                            createSpring(ls[i], ls[j]);
                        }
                    }
                }
            }
            for(var i = 0; i < ls.length; i++) {
                ls[i].selected = 0;
            }
        }

        two.bind('update', function () {

            if(!pause) {
                processSprings();
                processCircles();
            }

            for (var i = 0; i < ls.length; i++) {
                if(!pause) {
                    var obj = ls[i];
                    if(!ls[i].static) {
                        ls[i].pos.x += ls[i].vel.x;
                        ls[i].pos.y += ls[i].vel.y;
                    }
                    if (obj.pos.y - obj.radius < 0) {
                        obj.pos.y = obj.radius;
                        //obj.pos.y += 0.1;
                        obj.vel.y *= -.2;
                    }
                    if (obj.pos.y + obj.radius > two.height) {
                        obj.pos.y = two.height - obj.radius;
                        //obj.pos.y -= 0.1;
                        obj.vel.y *= -.2;
                    }
                    if (obj.pos.x + obj.radius > two.width) {
                        obj.pos.x = two.width - obj.radius;
                        //obj.pos.x -= 0.1;
                        obj.vel.x *= -.2;
                    }
                    if (obj.pos.x - obj.radius < 0) {
                        obj.pos.x = obj.radius;
                        //obj.pos.x += 0.1;
                        obj.vel.x *= -.2;
                    }
                }
                if(ls[i].selected) {
                    ls[i].shape.fill="#222222";
                } else {
                    if(ls[i].static) {
                        ls[i].shape.fill="#aaaaaa";
                    } else {
                        ls[i].shape.fill="#ffffff";
                    }
                }
                ls[i].shape.translation.x = ls[i].pos.x;
                ls[i].shape.translation.y = ls[i].pos.y;
                ls[i].line.translation.x = ls[i].pos.x;
                ls[i].line.translation.y = ls[i].pos.y;
            }
            for(var i = 0; i < springs.length; i++) {
                spring = springs[i];
                //spring.line.remove();
                //spring.line = two.makeLine(spring.s1.pos.x, spring.s1.pos.y, spring.s2.pos.x, spring.s2.pos.y);
                spring.line.vertices[0].x = spring.s1.pos.x;
                spring.line.vertices[0].y = spring.s1.pos.y;

                spring.line.vertices[1].x = spring.s2.pos.x;
                spring.line.vertices[1].y = spring.s2.pos.y;
            }

            if (mouseState || shiftClick) {
                for (var i = 0; i < ls.length; i++) {
                    if(mouseState) {
                        ls[i].selected = 0;
                    }
                    var delta = ls[i].pos.clone().sub(mousePos);
                    var distS = mousePos.clone().distanceTo(ls[i].pos);
                    if(distS > ls[i].radius) {
                        if(!dragging && !pause && mouseState) {
                            var norm = delta.clone().normalize().negate();
                            ls[i].vel.addSelf(
                                norm.clone().multiply(1 / distS)
                                    .multiply(1 / ls[i].mass)
                                    .multiply(16)
                            );
                        }
                    } else {
                        if(mouseState) {
                            draggingIdx = i;
                            dragging = true;
                        }
                        if(shiftClick) {
                            ls[i].selected = 1;
                        }
                    }
                }
                if(dragging) {
                    ls[draggingIdx].pos = mousePos.clone();
                    ls[draggingIdx].vel.clear();
                }
            }

        });

        document.body.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            return false;
        }); 
        
        document.addEventListener("mousemove", () => {
            let mousex = event.clientX; // Gets Mouse X
            let mousey = event.clientY; // Gets Mouse Y
            mousePos = new Two.Vector(mousex, mousey);
        });

        document.addEventListener("mousedown", (e) => {
            //console.log(e);
            if(e.button == 0) {
                if(e.shiftKey) {
                    shiftClick = 1;
                } else {
                    mouseState = 1;
                }
            } else if(e.button == 2) {
                createCircle(mousePos.clone(), zv());
            }
        });

        document.addEventListener("mouseup", () => {
            mouseState = 0;
            dragging = 0;
            draggingIdx = -1;
            shiftClick = 0;
        });

        document.addEventListener("keydown", (e) => {
            if(e.key == " ") {
                pause = !pause;
            } else if(e.key == "s") {
                linkSelectedCircles();
            } else if(e.key == "c") {
                for(var i = 0; i < ls.length; i++) {
                    two.remove(ls[i].shape);
                    two.remove(ls[i].line);
                }
                for(var i = 0; i < springs.length; i++) {
                    springs[i].line.remove();
                }
                springs.length = 0;
                ls.length = 0;
                springs = [];
                ls = [];
            } else if(e.key == "h") {
                for(var i = 0; i < ls.length; i++) {
                    if(ls[i].selected) {
                        ls[i].static = !ls[i].static;
                        ls[i].selected = 0;
                    }
                }
            }
        });

        function motion(event) {
            //console.log("Accelerometer: "
            // + event.accelerationIncludingGravity.x + ", "
            //  + event.accelerationIncludingGravity.y + ", "
            //  + event.accelerationIncludingGravity.z
            //);

            gravity.x = -event.accelerationIncludingGravity.x * 0.01;
            gravity.y = event.accelerationIncludingGravity.y * 0.01;
        }
        if (window.DeviceMotionEvent) {
            window.addEventListener("devicemotion", motion, false);
        } else {
            console.log("DeviceMotionEvent is not supported");
        }

    </script>
</body>
</html>